# -*- coding: utf-8 -*-
"""MAE & RMSE(Crop).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TkfklTTv9bnw5LhmuBizGJafK0qV22OI
"""

#Load and Preprocess the Dataset
import pandas as pd

df = pd.read_csv("crop_price_prediction_data.csv")

# Convert date to datetime
df['Date'] = pd.to_datetime(df['Date'])

# Sort and set index
df = df.sort_values('Date')
df.set_index('Date', inplace=True)

# Optional: Filter one crop for time series (e.g., Wheat)
crop_df = df[df['Crop Type'] == 'Wheat']

# Resample monthly mean price
price_data = crop_df['price(ton)'].resample('M').mean().ffill()

#ARIMA Model
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_error, mean_squared_error
from math import sqrt

# Fit ARIMA
model_arima = ARIMA(price_data, order=(5, 1, 0))
arima_fit = model_arima.fit()
forecast_arima = arima_fit.forecast(steps=12)

# Evaluate (last 12 months as test)
test = price_data[-12:]
mae_arima = mean_absolute_error(test, forecast_arima)
rmse_arima = sqrt(mean_squared_error(test, forecast_arima))
print(f'ARIMA MAE: {mae_arima:.2f}, RMSE: {rmse_arima:.2f}')

# Prophet Model
from prophet import Prophet
import matplotlib.pyplot as plt

# Prepare for Prophet
prophet_df = price_data.reset_index()
prophet_df.columns = ['ds', 'y']

model_prophet = Prophet()
model_prophet.fit(prophet_df)

# Forecast
future = model_prophet.make_future_dataframe(periods=12, freq='M')
forecast = model_prophet.predict(future)

# Plot
model_prophet.plot(forecast)
plt.show()

# Evaluate
forecast_values = forecast[['ds', 'yhat']].set_index('ds').yhat[-12:]
mae_prophet = mean_absolute_error(test, forecast_values)
rmse_prophet = sqrt(mean_squared_error(test, forecast_values))
print(f'Prophet MAE: {mae_prophet:.2f}, RMSE: {rmse_prophet:.2f}')

#LSTM Model
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
import numpy as np

# Preprocessing
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(price_data.values.reshape(-1, 1))

# Create sequences
def create_dataset(series, time_step=12):
    X, y = [], []
    for i in range(len(series) - time_step):
        X.append(series[i:i+time_step])
        y.append(series[i+time_step])
    return np.array(X), np.array(y)

time_step = 12
X, y = create_dataset(scaled_data, time_step)
X = X.reshape(X.shape[0], X.shape[1], 1)

# Build LSTM
model_lstm = Sequential([
    LSTM(50, return_sequences=True, input_shape=(time_step, 1)),
    LSTM(50),
    Dense(1)
])
model_lstm.compile(optimizer='adam', loss='mse')
model_lstm.fit(X, y, epochs=20, batch_size=16)

# Predict
last_seq = scaled_data[-time_step:].reshape(1, time_step, 1)
forecast_scaled = []
for _ in range(12):
    pred = model_lstm.predict(last_seq)
    forecast_scaled.append(pred[0, 0])
    # The issue was with the dimensions of [[pred]]. pred has shape (1,1) but needs to be (1,1,1)
    # Reshape pred to (1,1,1) and then select the correct elements for concatenation.
    last_seq = np.concatenate([last_seq[:, 1:, :], pred.reshape(1, 1, 1)], axis=1)

forecast_lstm = scaler.inverse_transform(np.array(forecast_scaled).reshape(-1, 1)).flatten()

mae_lstm = mean_absolute_error(test, forecast_lstm)
rmse_lstm = sqrt(mean_squared_error(test, forecast_lstm))
print(f'LSTM MAE: {mae_lstm:.2f}, RMSE: {rmse_lstm:.2f}')

from flask import Flask, request

# Initialize Flask app
app = Flask(__name__)

# Forecast future
def forecast_next_12():
    last_seq = scaled[-step:].reshape(1, step, 1)
    forecast_scaled = []
    for _ in range(12):
        pred = model.predict(last_seq)
        forecast_scaled.append(pred[0, 0])
        last_seq = np.append(last_seq[:, 1:, :], [[pred]], axis=1)
    return scaler.inverse_transform(np.array(forecast_scaled).reshape(-1, 1)).flatten()

@app.route('/')
def home():
    return '''
    <h2>Crop Price Forecast</h2>
    <form method="post" action="/predict">
        <label>Crop Type:</label>
        <input name="crop" type="text" value="Wheat"/>
        <input type="submit"/>
    </form>
    '''

@app.route('/predict', methods=['POST'])
def predict():
    crop = request.form['crop']
    forecast = forecast_next_12()
    result = '<br>'.join([f'Month {i+1}: â‚¹{p:.2f}' for i, p in enumerate(forecast)])
    return f"<h3>12-Month Forecast for {crop}:</h3><p>{result}</p>"

if __name__ == '__main__':
    app.run(debug=True)

